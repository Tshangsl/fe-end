<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数作用域</title>
</head>
<body>
    <button id = "btn">click me</button>
    <script>
        //对象：everyting is object 一切皆对象
        
        // var bth = document.getElementById('btn');
        // btn.onclick = function(){
        //     var str = 'hh';
        //     setTimeout(function(){
        //         console.log(str);
        //     },2000);
        // }
        // var x = 5;
        // function test(){
        //     var x = 6;
        //     function test2(){
        //         console.log(x);
        //     }
        //     test2();
        // }
        // test()
        //在函数内部使用var声明的变量是局部变量
        // var x = 6;//全局变量
        // function test(){
        //     //console.log(x);
        //     //变量提升
        //     x = 5;
        //     var y = 8;//局部变量
        // }
        // test();
        // console.log(x);
        //  var x = 5;
        // function test(){
        //     console.log(x);
        //    var x = 6;//在函数内部不以var声明的变量也是全局的
        // }
        // test();
        // console.log(x);

        //词法作用域
        //指函数在定义（或声明）它们的定义域里运行
	    //而不是在执行/调用它们的作用域里运行
        // var value = 1;
        // function foo(){
        //     console.log(value);
        // }
        // function bar(){
        //     var value = 2;
        //     foo();
        // }
        // bar();//输出 1



        // function test(name,age){
        //     console.log(name,age,arguments[]);
        // }
        // test('lisa',23,'女');

        //10! 阶乘
        // function fac(n){
        //     var num = 1;
        //     for(var i = 1;i<=n;i++){
        //         num*=i;
        //     }
        //     return num;
        // }
        // console.log(fac(10));

        //递归实现求前n项和
        //  function fac(){
        //      if ( n==1 ){
        //          return 1;
        //      }
        //      return n*fac(n-1);
        //      //10*f(9)
        //      //9*f(8)
        //  }
        //  console.log(fac(10));


        //递归实现斐波那契
        // function Fibonacci(n){
        //     if(n<=2){
        //         return 1;
        //     }
        //     return arguments.callee(n-2)+arguments.callee(n-1);
        // }
        // console.log(Fibonacci(5));

        //闭包:在外部函数的内部声明内部函数，在内部函数里引用了外部函数的局部变量
        //变量，当外部函数调用完毕后，局部变量不被释放
        // function fn1(){
        //     var a = 5;
        //     function fn2(){
        //         return a;
        //     }
        //     return fn2;
        // }
        // var b = fn1();
        // console.log(b());
        // for(var i=0;i<3;i++){

        // }
        //运行一次
        // setTimeout(function(){
        //     console.log('dd');
        // },2000)
        //不断运行
        // setInterval(function(){
        //     console.log('dd');
        // },2000)

            //？
        //闭包的应用
        // for(var i = 0;i<3;i++){
            //传给了外部函数的局部变量
        //    (function(index){
        //     setTimeout(function(){
        //        console.log(index);
        //    },(index+1)*1000);
        //    })(i);
        // }

            //？
        // for(var i = 0;i<3;i++){
        //     setTimeout(function(){
        //         //定时器开始执行的时候
        //         (function(index){
        //             console.log(index);
        //         })(i);
        //     },(i+1)*1000)
        // }

        //立即执行函数/函数立即调用
        // (function(name){

        // })('lisi')
    </script>
</body>
</html>







